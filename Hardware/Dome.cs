using System;using System.Collections.Generic;using System.Threading;using System.Threading.Tasks;using System.Xml.Serialization;using ASCOM.DeviceInterface;using heliomaster.Properties;namespace heliomaster {    /// <summary> A dome controlled via its ASCOM interface. </summary>    public class Dome : BaseHardwareControl {        [XmlIgnore] protected override Type driverType => typeof(ASCOM.DriverAccess.Dome);        [XmlIgnore] public IDomeV2 Driver => driver as IDomeV2;        public override string Type => Resources.dome;        #region properties        /// <summary> The dome azimuth in degrees from north through east, south and west. </summary>        /// <remarks> A null value indicates that the hardware is not connected. </remarks>        public double? Azimuth => Valid ? Driver.Azimuth : (double?) null;                /// <summary> Whether the dome is at the home position. </summary>        /// <remarks> A null value indicates that the hardware is not connected. </remarks>        public bool? AtHome {            get {                if (Valid)                    try {return Driver.AtHome;}                    catch {return null;}                else return null;            }        }                /// <summary> Whether the dome is at the park position. </summary>        /// <remarks> A null value indicates that the hardware is not connected. </remarks>        public bool? AtPark {            get {                if (Valid)                    try {return Driver.AtPark;}                    catch {return null;}                else return null;            }        }        /// <summary> Whether the dome is currently slewing. </summary>        /// <remarks> A null value indicates that the hardware is not connected. </remarks>        public bool? Slewing => Valid ? Driver.Slewing : (bool?) null;        /// <summary> Whether the dome is currently slaved to a mount. </summary>        /// <remarks>        ///     <para>This value reflects only hardware slaving implemented through the ASCOM driver.</para>        ///     <para>A null value indicates that the hardware is not connected.</para>        /// </remarks>        public bool? Slaved => Valid ? Driver.Slaved : (bool?) null;                /// <summary> The status of the dome shutter. </summary>        /// <remarks> A null value indicates that the hardware is not connected. </remarks>        public ShutterState? ShutterStatus => Valid ? Driver.ShutterStatus : (ShutterState?) null;        /// <summary> Whether the dome can currently control its shutter. </summary>        /// <remarks> Checks whether the hardware is connected and whether the driver has shutter control capabilities. </remarks>        public bool CanShutter => Valid && Driver.CanSetShutter;                /// <summary> Whether the dome can currently slave to a mount. </summary>        /// <remarks> Checks whether the hardware is connected and whether the driver has slaving capabilities. </remarks>        public bool CanSlave => Valid && Driver.CanSlave;                /// <summary> Whether the dome can currently be set in motion. </summary>        /// <remarks> Checks whether the hardware is connected and whether it is not currently moving or slaved to a        /// mount. </remarks>        public bool Moveable => Slaved==false && Slewing==false;                /// <summary> Whether the dome can currently be parked. </summary>        /// <remarks> Checks whether the dome is <see cref="Moveable"/>, whether the driver has parking capabilities        /// and whether it is not currently parked. </remarks>        public bool CanPark => Moveable && Driver.CanPark && AtPark==false;                /// <summary> Whether the dome can currently be sent to home. </summary>        /// <remarks> Checks whether the dome is <see cref="Moveable"/>, whether the driver has homeing capabilities        /// and whether it is not currently at home. </remarks>        public bool CanHome => Moveable && Driver.CanFindHome && AtHome==false;        private static readonly string[] _props = {            nameof(Azimuth), nameof(ShutterStatus),            nameof(AtHome), nameof(AtPark), nameof(Slewing), nameof(Slaved),            nameof(CanShutter), nameof(CanSlave), nameof(CanPark), nameof(CanHome),            nameof(Moveable)        };        protected override IEnumerable<string> props => _props;        #endregion                private double _homePosition;        /// <summary> The Azimuth of the home position of the dome. </summary>        public double HomePosition {            get => _homePosition;            set {                if (value.Equals(_homePosition)) return;                _homePosition = value;                OnPropertyChanged();            }        }        private double _parkPosition;        /// <summary> The Azimuth of the park position of the dome. </summary>        public double ParkPosition {            get => _parkPosition;            set {                if (value.Equals(_parkPosition)) return;                _parkPosition = value;                OnPropertyChanged();            }        }        private bool _homeToShutter;        /// <summary> Whether controlling the shutter requires the dome to be at home. </summary>        public bool HomeToShutter {            get => _homeToShutter;            set {                if (value == _homeToShutter) return;                _homeToShutter = value;                OnPropertyChanged();            }        }        private bool _retryShutter;        /// <summary> Whether to retry shutter operations. See <see cref="SmartShutter"/> for more details. </summary>        public bool RetryShutter {            get => _retryShutter;            set {                if (value == _retryShutter) return;                _retryShutter = value;                OnPropertyChanged();            }        }        #region MOTION        /// <summary> Attempt to slew the dome. </summary>        /// <param name="arg">If <paramref name="absolute"/>, this is the desired Azimuth position. Otherwise, it        /// is an offset from the current one. In both cases it is given in degrees.</param>        /// <param name="absolute">Whether <paramref name="arg"/> is an absolute or relative position.</param>        /// <returns></returns>        public Task<bool> Slew(double arg, bool absolute = false) {            const string pre = "DOME: Slew: ";            return Task<bool>.Factory.StartNew(() => {                try {                    if (Moveable && Azimuth is double az) {                        var target = Utilities.PositiveModulo(absolute ? arg : az + arg, 360);                        Logger.debug(pre + $"arg={arg}, target={target}");                        Driver.SlewToAzimuth(target);                                                    // Wait for slewing to start... It might not start at all, if the driver is in fact disconnected.                        SpinWait.SpinUntil(() => Slewing==true, new TimeSpan(0, 0, 10)); // TODO: Unhardcode                        // Wait for slewing to stop...                        SpinWait.SpinUntil(() => Slewing==false);                                                    Logger.info(pre + "success.");                        return true;                    } else throw new Exception("Dome is not movable.");                } catch (Exception e) {                    Logger.warning(pre + $"failed: {e.Message}");                    return false;                } finally { RefreshRaise(); }            });        }        /// <summary> Stop all dome motion, including rotation and shutter. </summary>        /// <returns> Whether the operation was successful. </returns>        public Task<bool> StopAllMotion() {            Logger.info("Stopping all motion.");            return Task<bool>.Factory.StartNew(() => {                try {                    Driver.AbortSlew();                    Logger.info("AbortSlew complete.");                    return true;                }                catch {                    Logger.warning("AbortSlew failed.");                    return false;                }                finally { RefreshRaise(); }            });        }        /// <summary> Attempt to rotate the dome to its home or park position. </summary>        /// <param name="home">Whether to rotate to the home (<c>true</c>) or park (<c>false</c>) position.</param>        /// <remarks> This method first attempts to use the corresponding functions in the driver        /// (<see cref="IDomeV2.FindHome"/> and <see cref="IDomeV2.Park"/>) and if unsuccessful, attempts to slew the        ///  dome to the Azimuth of the desired position (as stored in <see cref="HomePosition"/> and        /// <see cref="ParkPosition"/>). </remarks>        /// <returns> Whether the driver reports the correct position after the operation is completed. </returns>        public Task<bool> HomeOrPark(bool home) {            var pre = home ? "DOME HOME: " : "DOME PARK: ";            Logger.info(pre + "starting.");            return Task<bool>.Factory.StartNew(() => {                try {                    if (home) Driver.FindHome();                    else Driver.Park();                    var timeout = TimeSpan.FromSeconds(100); // TODO: Unhardcode                    SpinWait.SpinUntil(() => (home && Driver.AtHome) || (!home && Driver.AtPark), timeout);                    Logger.info(pre + $"Slewing stopped or timeout {timeout.TotalSeconds}s expired.");                    return (home ? AtHome : AtPark) == true;                } catch {                    Logger.debug(pre + $"Attempting software {(home ? "slew to home" : "park")}.");                    var t = Slew(home ? HomePosition : ParkPosition);                    t.Wait();                    if (t.Exception != null || !t.Result) {                        Logger.warning(pre + "failed.");                        return false;                    } else {                        Logger.info(pre + "complete.");                        return true;                    }                } finally { RefreshRaise(); }            });        }        /// <summary> Attempt to put the driver into the desired slaving state. </summary>        /// <param name="state">Whether to slave or unslave the dome.</param>        /// <returns>Whether the operation was successful.</returns>        public Task<bool> Slave(bool state) {            var action = (state ? "Slaving " : "Unslaving") + " via hardware";            Logger.info($"{action}.");            return Task<bool>.Factory.StartNew(() => {                try {                    Driver.Slaved = state;                } catch (Exception e) {                    Logger.error(e.Message);                }                RefreshRaise();                var ret = Driver.Slaved == state;                if (!ret) Logger.warning($"{action} failed.");                else      Logger.info($"{action} complete.");                return ret;            });        }        /// <summary> Try to set the shutter to the desired state. </summary>        /// <param name="open">Whether to open or close the shutter.</param>        /// <remarks> This method simply asks the driver to control the shutter and waits at most        /// <see cref="DomeSettings.ShutterTimeout"/> for the shutter state to become as desired.</remarks>        /// <returns>Whether the operation was successful.</returns>        public Task<bool> Shutter(bool open) {            var pre = $"DOME: Shutter({open}): ";            return Task<bool>.Factory.StartNew(() => {                var state = open ? ShutterState.shutterOpen : ShutterState.shutterClosed;                try {                    if (open) Driver.OpenShutter();                    else Driver.CloseShutter();                    SpinWait.SpinUntil(() => !Driver.Slewing && Driver.ShutterStatus == state, S.Dome.ShutterTimeout);                } catch (Exception e) {                    Logger.error(e.Message);                }                RefreshRaise();                var ret = Driver.ShutterStatus == state;                if (!ret) Logger.warning(pre + "failed.");                else      Logger.info(pre + "complete.");                return ret;            });        }        /// <summary> Try hard to set the shutter to the desired state, taking the dome to its home position if needed. </summary>        /// <param name="open">Whether to open or close the shutter.</param>        /// <param name="tryreboot">Whether to try to reboot the dome if slewing is unsuccessful.</param>        /// <remarks> The method proceeds as follows: If controlling the shutter requires being at home        /// (<see cref="HomeToShutter"/>), the method attempts to rotate the dome to home via <see cref="HomeOrPark"/>.        /// If this is unsuccessful and <paramref name="tryreboot"/> is <c>true</c>, it attempts to reboot the dome and        /// again tries to position it at home. Once at home, it tries to control the shutter and returns whether the        /// call to <see cref="Shutter"/> was successful. If slewing to is impossible even after a reboot, the method        /// gives up and returns <c>false</c>.        /// </remarks>        /// <returns>Whether the operation was successful.</returns>        public async Task<bool> ShutterWithHome(bool open, bool tryreboot = true) {            var pre = $"DOME: ShutterWithHome({open}): ";            while (true) {                if (!HomeToShutter || await HomeOrPark(home: true)) {                    var ret = await Shutter(open);                    Logger.info(pre + (ret ? "success" : "failed: cannot control shutter"));                    return ret;                }                if (tryreboot) {                    Logger.info(pre + "rebooting");                    if (await Reboot()) {                        tryreboot = false;                        continue;                    } else Logger.info(pre + "rebooting failed");                }                Logger.info(pre + "failed: cannot go to home");                return false;            }        }        /// <summary> Try very hard to set the shutter to the desired state. </summary>        /// <param name="open">Whether to open or close the shutter.</param>        /// <remarks> The method proceeds as follows: An attempt is made to operate the shutter using        /// <see cref="ShutterWithHome"/>. If it is unsuccessful, and <see cref="RetryShutter"/> is <c>true</c>, then        /// another attempt is made after the dome is rotated away from its current position.        /// (<see cref="ShutterWithHome"/> then takes it to home if necessary.) If this fails as well, as a last resort        /// the dome is rebooted using <see cref="BaseHardwareControl.Reboot"/> and shutter control retried. If this        /// fails, the method gievs up and returns <c>false</c>.         /// </remarks>        /// <returns>Whether the operation was successful.</returns>        public async Task<bool> SmartShutter(bool open) {            var prefix = $"DOME: SmartShutter({open}): ";            Logger.info(prefix + "starting");            try {                if (await ShutterWithHome(open)) goto success;                if (RetryShutter) {                    Logger.info(prefix + "unsuccessful");                    if (HomeToShutter) {                        Logger.info(prefix + "trying to re-go to home");                        if (await Slew(20) && await ShutterWithHome(open)) goto success;                    } // TODO: Unhardcode Slew(20)                    Logger.info(prefix + "trying to reboot");                    if (await Reboot()) {                        Logger.info(prefix + "reboot successful");                        if (await ShutterWithHome(open)) goto success;                    }                }            } catch (Exception e) {                Logger.info(prefix + Utilities.FormatException(e));            }            Logger.info(prefix + "failed");            return false;            success:            Logger.info(prefix + "success");            return true;        }        #endregion    }}